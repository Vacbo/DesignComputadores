tmp(0) := x"4" & '0' & x"00"; -- LDI $0      
tmp(1) := x"5" & '0' & x"00"; -- STA @0      
tmp(2) := x"5" & '0' & x"02"; -- STA @2      #zera count unidades
tmp(3) := x"5" & '0' & x"03"; -- STA @3      #zera count dezenas
tmp(4) := x"5" & '0' & x"04"; -- STA @4      #zera count centenas
tmp(5) := x"5" & '0' & x"05"; -- STA @5      #zera count milhares
tmp(6) := x"5" & '0' & x"06"; -- STA @6      #zera count dezenas de milhares
tmp(7) := x"5" & '0' & x"07"; -- STA @7      #zera count centenas de milhares
tmp(8) := x"5" & '1' & x"00"; -- STA @256      #zera led 70
tmp(9) := x"5" & '1' & x"20"; -- STA @288      
tmp(10) := x"5" & '1' & x"21"; -- STA @289      
tmp(11) := x"5" & '1' & x"22"; -- STA @290      
tmp(12) := x"5" & '1' & x"23"; -- STA @291      
tmp(13) := x"5" & '1' & x"24"; -- STA @292      
tmp(14) := x"5" & '1' & x"25"; -- STA @293      
tmp(15) := x"5" & '0' & x"0E"; -- STA @14      
tmp(16) := x"4" & '0' & x"01"; -- LDI $1      
tmp(17) := x"5" & '0' & x"01"; -- STA @1      
tmp(18) := x"9" & '0' & x"D0"; -- JSR @208      #chama subrotina verifica_limite
tmp(19) := x"9" & '1' & x"2B"; -- JSR @299      #chama subrotina verifica_zero
tmp(20) := x"9" & '1' & x"3C"; -- JSR @316      #chama subrotina verifica_ovf
tmp(21) := x"1" & '1' & x"60"; -- LDA @352      #le key 0
tmp(22) := x"B" & '0' & x"01"; -- AND @1      #macara para key 0
tmp(23) := x"8" & '0' & x"01"; -- CEQ @1      
tmp(24) := x"C" & '0' & x"1A"; -- JNE @26      #pula para key1
tmp(25) := x"9" & '0' & x"2A"; -- JSR @42      #chama subrotina incrementa
tmp(26) := x"1" & '1' & x"61"; -- LDA @353      #le key 1
tmp(27) := x"B" & '0' & x"01"; -- AND @1      #macara para key 1
tmp(28) := x"8" & '0' & x"01"; -- CEQ @1      
tmp(29) := x"C" & '0' & x"1F"; -- JNE @31      #pula para key2
tmp(30) := x"9" & '0' & x"6B"; -- JSR @107      #chama subrotina configura_limite
tmp(31) := x"1" & '1' & x"62"; -- LDA @354      #le key 2
tmp(32) := x"B" & '0' & x"01"; -- AND @1      #macara para key 2
tmp(33) := x"8" & '0' & x"01"; -- CEQ @1      
tmp(34) := x"C" & '0' & x"24"; -- JNE @36      #pula para key3
tmp(35) := x"9" & '0' & x"EA"; -- JSR @234      #chama subrotina decrementa
tmp(36) := x"1" & '1' & x"63"; -- LDA @355      #le key 3
tmp(37) := x"B" & '0' & x"01"; -- AND @1      #macara para key 3
tmp(38) := x"8" & '0' & x"01"; -- CEQ @1      
tmp(39) := x"C" & '0' & x"12"; -- JNE @18      
tmp(40) := x"9" & '1' & x"50"; -- JSR @336      #chama subrotina configura_count
tmp(41) := x"6" & '0' & x"12"; -- JMP @18      #volta para loop
tmp(42) := x"5" & '1' & x"FF"; -- STA @511      #limpa key
tmp(43) := x"1" & '0' & x"0E"; -- LDA @14      #le flag de limite
tmp(44) := x"8" & '0' & x"01"; -- CEQ @1      #compara com 1
tmp(45) := x"7" & '0' & x"6A"; -- JEQ @106      #se flag de limite for 1, pula para :retinc
tmp(46) := x"1" & '0' & x"02"; -- LDA @2      #le count unidades
tmp(47) := x"2" & '0' & x"01"; -- SOMA @1      #soma 1
tmp(48) := x"5" & '0' & x"02"; -- STA @2      #salva count unidades
tmp(49) := x"5" & '1' & x"20"; -- STA @288      #mostra count unidades
tmp(50) := x"4" & '0' & x"0A"; -- LDI $10      
tmp(51) := x"8" & '0' & x"02"; -- CEQ @2      #compara unidade com 10
tmp(52) := x"7" & '0' & x"36"; -- JEQ @54      #se for 10, pula para :rstu
tmp(53) := x"A" & '0' & x"00"; -- RET       #retorna
tmp(54) := x"4" & '0' & x"00"; -- LDI $0      
tmp(55) := x"5" & '0' & x"02"; -- STA @2      #zera count unidades
tmp(56) := x"5" & '1' & x"20"; -- STA @288      #zera count unidades
tmp(57) := x"1" & '0' & x"03"; -- LDA @3      #le count dezenas
tmp(58) := x"2" & '0' & x"01"; -- SOMA @1      #soma 1
tmp(59) := x"5" & '0' & x"03"; -- STA @3      #salva count dezenas
tmp(60) := x"5" & '1' & x"21"; -- STA @289      #mostra count dezenas
tmp(61) := x"4" & '0' & x"0A"; -- LDI $10      
tmp(62) := x"8" & '0' & x"03"; -- CEQ @3      #compara dezena com 10
tmp(63) := x"7" & '0' & x"41"; -- JEQ @65      #se for 10, pula para :rstd
tmp(64) := x"A" & '0' & x"00"; -- RET       #retorna
tmp(65) := x"4" & '0' & x"00"; -- LDI $0      
tmp(66) := x"5" & '0' & x"03"; -- STA @3      #zera count dezenas
tmp(67) := x"5" & '1' & x"21"; -- STA @289      #zera count dezenas
tmp(68) := x"1" & '0' & x"04"; -- LDA @4      #le count centenas
tmp(69) := x"2" & '0' & x"01"; -- SOMA @1      #soma 1
tmp(70) := x"5" & '0' & x"04"; -- STA @4      #salva count centenas
tmp(71) := x"5" & '1' & x"22"; -- STA @290      #mostra count centenas
tmp(72) := x"4" & '0' & x"0A"; -- LDI $10      
tmp(73) := x"8" & '0' & x"04"; -- CEQ @4      #compara centena com 10
tmp(74) := x"7" & '0' & x"4C"; -- JEQ @76      #se for 10, pula para :rstc
tmp(75) := x"A" & '0' & x"00"; -- RET       #retorna
tmp(76) := x"4" & '0' & x"00"; -- LDI $0      
tmp(77) := x"5" & '0' & x"04"; -- STA @4      #zera count centenas
tmp(78) := x"5" & '1' & x"22"; -- STA @290      #zera count centenas
tmp(79) := x"1" & '0' & x"05"; -- LDA @5      #le count milhares
tmp(80) := x"2" & '0' & x"01"; -- SOMA @1      #soma 1
tmp(81) := x"5" & '0' & x"05"; -- STA @5      #salva count milhares
tmp(82) := x"5" & '1' & x"23"; -- STA @291      #mostra count milhares
tmp(83) := x"4" & '0' & x"0A"; -- LDI $10      
tmp(84) := x"8" & '0' & x"05"; -- CEQ @5      #compara milhar com 10
tmp(85) := x"7" & '0' & x"57"; -- JEQ @87      #se for 10, pula para :rstm
tmp(86) := x"A" & '0' & x"00"; -- RET       #retorna
tmp(87) := x"4" & '0' & x"00"; -- LDI $0      
tmp(88) := x"5" & '0' & x"05"; -- STA @5      #zera count milhares
tmp(89) := x"5" & '1' & x"23"; -- STA @291      #zera count milhares
tmp(90) := x"1" & '0' & x"06"; -- LDA @6      #le count dezenas de milhares
tmp(91) := x"2" & '0' & x"01"; -- SOMA @1      #soma 1
tmp(92) := x"5" & '0' & x"06"; -- STA @6      #salva count dezenas de milhares
tmp(93) := x"5" & '1' & x"24"; -- STA @292      #mostra count dezenas de milhares
tmp(94) := x"4" & '0' & x"0A"; -- LDI $10      
tmp(95) := x"8" & '0' & x"06"; -- CEQ @6      #compara dezena de milhar com 10
tmp(96) := x"7" & '0' & x"62"; -- JEQ @98      #se for 10, pula para :rstdm
tmp(97) := x"A" & '0' & x"00"; -- RET       #retorna
tmp(98) := x"4" & '0' & x"00"; -- LDI $0      
tmp(99) := x"5" & '0' & x"06"; -- STA @6      #zera count dezenas de milhares
tmp(100) := x"5" & '1' & x"24"; -- STA @292      #zera count dezenas de milhares
tmp(101) := x"1" & '0' & x"07"; -- LDA @7      #le count centenas de milhares
tmp(102) := x"2" & '0' & x"01"; -- SOMA @1      #soma 1STA !LED70
tmp(103) := x"4" & '0' & x"00"; -- LDI $0      
tmp(104) := x"5" & '0' & x"07"; -- STA @7      #zera count centenas de milhares
tmp(105) := x"5" & '1' & x"25"; -- STA @293      #zera count centenas de milhares
tmp(106) := x"A" & '0' & x"00"; -- RET       
tmp(107) := x"5" & '1' & x"FE"; -- STA @510      #limpa key 1
tmp(108) := x"4" & '0' & x"0F"; -- LDI $15      
tmp(109) := x"5" & '1' & x"20"; -- STA @288      #F Hex0
tmp(110) := x"5" & '1' & x"21"; -- STA @289      
tmp(111) := x"5" & '1' & x"22"; -- STA @290      
tmp(112) := x"5" & '1' & x"23"; -- STA @291      
tmp(113) := x"5" & '1' & x"24"; -- STA @292      
tmp(114) := x"5" & '1' & x"25"; -- STA @293      #F Hex5
tmp(115) := x"4" & '0' & x"01"; -- LDI $1      
tmp(116) := x"5" & '1' & x"00"; -- STA @256      #LED mostra que configura_limite 1
tmp(117) := x"4" & '0' & x"0F"; -- LDI $15      
tmp(118) := x"B" & '1' & x"40"; -- AND @320      #mascara para Switch 70
tmp(119) := x"5" & '1' & x"23"; -- STA @291      #mostra Switch 70
tmp(120) := x"1" & '1' & x"61"; -- LDA @353      #le key 1
tmp(121) := x"B" & '0' & x"01"; -- AND @1      #mascara para key 1
tmp(122) := x"8" & '0' & x"01"; -- CEQ @1      #ve se key 1 foi pressionado
tmp(123) := x"C" & '0' & x"75"; -- JNE @117      #se nao foi pressionado, volta para :loop_lmt_u
tmp(124) := x"5" & '1' & x"FE"; -- STA @510      #limpa key 1
tmp(125) := x"4" & '0' & x"0F"; -- LDI $15      
tmp(126) := x"B" & '1' & x"40"; -- AND @320      #mascara para Switch 70
tmp(127) := x"5" & '0' & x"08"; -- STA @8      #salva limite unidades
tmp(128) := x"4" & '0' & x"02"; -- LDI $2      
tmp(129) := x"5" & '1' & x"00"; -- STA @256      #LED mostra que configura_limite 2
tmp(130) := x"4" & '0' & x"0F"; -- LDI $15      
tmp(131) := x"B" & '1' & x"40"; -- AND @320      #mascara para Switch 70
tmp(132) := x"5" & '1' & x"23"; -- STA @291      #mostra Switch 70
tmp(133) := x"1" & '1' & x"61"; -- LDA @353      #le key 1
tmp(134) := x"B" & '0' & x"01"; -- AND @1      #mascara para key 1
tmp(135) := x"8" & '0' & x"01"; -- CEQ @1      #ve se key 1 foi pressionado
tmp(136) := x"C" & '0' & x"82"; -- JNE @130      #se nao foi pressionado, volta para :loop_lmt_d
tmp(137) := x"5" & '1' & x"FE"; -- STA @510      #limpa key 1
tmp(138) := x"4" & '0' & x"0F"; -- LDI $15      
tmp(139) := x"B" & '1' & x"40"; -- AND @320      #mascara para Switch 70
tmp(140) := x"5" & '0' & x"09"; -- STA @9      #salva limite dezenas
tmp(141) := x"4" & '0' & x"04"; -- LDI $4      
tmp(142) := x"5" & '1' & x"00"; -- STA @256      #LED mostra que configura_limite 3
tmp(143) := x"4" & '0' & x"0F"; -- LDI $15      
tmp(144) := x"B" & '1' & x"40"; -- AND @320      #mascara para Switch 70
tmp(145) := x"5" & '1' & x"23"; -- STA @291      #mostra Switch 70
tmp(146) := x"1" & '1' & x"61"; -- LDA @353      #le key 1
tmp(147) := x"B" & '0' & x"01"; -- AND @1      #mascara para key 1
tmp(148) := x"8" & '0' & x"01"; -- CEQ @1      #ve se key 1 foi pressionado
tmp(149) := x"C" & '0' & x"8F"; -- JNE @143      #se nao foi pressionado, volta para :loop_lmt_c
tmp(150) := x"5" & '1' & x"FE"; -- STA @510      #limpa key 1
tmp(151) := x"4" & '0' & x"0F"; -- LDI $15      
tmp(152) := x"B" & '1' & x"40"; -- AND @320      #mascara para Switch 70
tmp(153) := x"5" & '0' & x"0A"; -- STA @10      #salva limite centenas
tmp(154) := x"4" & '0' & x"08"; -- LDI $8      
tmp(155) := x"5" & '1' & x"00"; -- STA @256      #LED mostra que configura_limite 4
tmp(156) := x"4" & '0' & x"0F"; -- LDI $15      
tmp(157) := x"B" & '1' & x"40"; -- AND @320      #mascara para Switch 70
tmp(158) := x"5" & '1' & x"23"; -- STA @291      #mostra Switch 70
tmp(159) := x"1" & '1' & x"61"; -- LDA @353      #le key 1
tmp(160) := x"B" & '0' & x"01"; -- AND @1      #mascara para key 1
tmp(161) := x"8" & '0' & x"01"; -- CEQ @1      #ve se key 1 foi pressionado
tmp(162) := x"C" & '0' & x"9C"; -- JNE @156      #se nao foi pressionado, volta para :loop_lmt_m
tmp(163) := x"5" & '1' & x"FE"; -- STA @510      #limpa key 1
tmp(164) := x"4" & '0' & x"0F"; -- LDI $15      
tmp(165) := x"B" & '1' & x"40"; -- AND @320      #mascara para Switch 70
tmp(166) := x"5" & '0' & x"0B"; -- STA @11      #salva limite milhares
tmp(167) := x"4" & '0' & x"10"; -- LDI $16      
tmp(168) := x"5" & '1' & x"00"; -- STA @256      #LED mostra que configura_limite 5
tmp(169) := x"4" & '0' & x"0F"; -- LDI $15      
tmp(170) := x"B" & '1' & x"40"; -- AND @320      #mascara para Switch 70
tmp(171) := x"5" & '1' & x"23"; -- STA @291      #mostra Switch 70
tmp(172) := x"1" & '1' & x"61"; -- LDA @353      #le key 1
tmp(173) := x"B" & '0' & x"01"; -- AND @1      #mascara para key 1
tmp(174) := x"8" & '0' & x"01"; -- CEQ @1      #ve se key 1 foi pressionado
tmp(175) := x"C" & '0' & x"A9"; -- JNE @169      #se nao foi pressionado, volta para :loop_lmt_dm
tmp(176) := x"5" & '1' & x"FE"; -- STA @510      #limpa key 1
tmp(177) := x"4" & '0' & x"0F"; -- LDI $15      
tmp(178) := x"B" & '1' & x"40"; -- AND @320      #mascara para Switch 70
tmp(179) := x"5" & '0' & x"0C"; -- STA @12      #salva limite dezenas de milhares
tmp(180) := x"4" & '0' & x"20"; -- LDI $32      
tmp(181) := x"5" & '1' & x"00"; -- STA @256      #LED mostra que configura_limite 6
tmp(182) := x"4" & '0' & x"0F"; -- LDI $15      
tmp(183) := x"B" & '1' & x"40"; -- AND @320      #mascara para Switch 70
tmp(184) := x"5" & '1' & x"23"; -- STA @291      #mostra Switch 70
tmp(185) := x"1" & '1' & x"61"; -- LDA @353      #le key 1
tmp(186) := x"B" & '0' & x"01"; -- AND @1      #mascara para key 1
tmp(187) := x"8" & '0' & x"01"; -- CEQ @1      #ve se key 1 foi pressionado
tmp(188) := x"C" & '0' & x"B6"; -- JNE @182      #se nao foi pressionado, volta para :loop_lmt_cm
tmp(189) := x"5" & '1' & x"FE"; -- STA @510      #limpa key 1
tmp(190) := x"4" & '0' & x"0F"; -- LDI $15      
tmp(191) := x"B" & '1' & x"40"; -- AND @320      #mascara para Switch 70
tmp(192) := x"5" & '0' & x"0D"; -- STA @13      #salva limite centenas de milhares
tmp(193) := x"4" & '0' & x"00"; -- LDI $0      
tmp(194) := x"5" & '1' & x"00"; -- STA @256      #LED mostra que configura_limite 0
tmp(195) := x"1" & '0' & x"02"; -- LDA @2      #comeca voltar valores hex
tmp(196) := x"5" & '1' & x"20"; -- STA @288      
tmp(197) := x"1" & '0' & x"03"; -- LDA @3      
tmp(198) := x"5" & '1' & x"21"; -- STA @289      
tmp(199) := x"1" & '0' & x"04"; -- LDA @4      
tmp(200) := x"5" & '1' & x"22"; -- STA @290      
tmp(201) := x"1" & '0' & x"05"; -- LDA @5      
tmp(202) := x"5" & '1' & x"23"; -- STA @291      
tmp(203) := x"1" & '0' & x"06"; -- LDA @6      
tmp(204) := x"5" & '1' & x"24"; -- STA @292      
tmp(205) := x"1" & '0' & x"07"; -- LDA @7      #termina voltar valores hex
tmp(206) := x"5" & '1' & x"25"; -- STA @293      
tmp(207) := x"A" & '0' & x"00"; -- RET       
tmp(208) := x"1" & '0' & x"02"; -- LDA @2      #le count unidades
tmp(209) := x"8" & '0' & x"08"; -- CEQ @8      #compara com limite unidades
tmp(210) := x"C" & '0' & x"E6"; -- JNE @230      
tmp(211) := x"1" & '0' & x"03"; -- LDA @3      #le count dezenas
tmp(212) := x"8" & '0' & x"09"; -- CEQ @9      #compara com limite dezenas
tmp(213) := x"C" & '0' & x"E6"; -- JNE @230      
tmp(214) := x"1" & '0' & x"04"; -- LDA @4      #le count centenas
tmp(215) := x"8" & '0' & x"0A"; -- CEQ @10      #compara com limite centenas
tmp(216) := x"C" & '0' & x"E6"; -- JNE @230      
tmp(217) := x"1" & '0' & x"05"; -- LDA @5      #le count milhares
tmp(218) := x"8" & '0' & x"0B"; -- CEQ @11      #compara com limite milhares
tmp(219) := x"C" & '0' & x"E6"; -- JNE @230      
tmp(220) := x"1" & '0' & x"06"; -- LDA @6      #le count dezenas de milhares
tmp(221) := x"8" & '0' & x"0C"; -- CEQ @12      #compara com limite dezenas de milhares
tmp(222) := x"C" & '0' & x"E6"; -- JNE @230      
tmp(223) := x"1" & '0' & x"07"; -- LDA @7      #le count centenas de milhares
tmp(224) := x"8" & '0' & x"0D"; -- CEQ @13      #compara com limite centenas de milhares
tmp(225) := x"C" & '0' & x"E6"; -- JNE @230      
tmp(226) := x"4" & '0' & x"01"; -- LDI $1      
tmp(227) := x"5" & '1' & x"01"; -- STA @257      #LED mostra que alcancou limite
tmp(228) := x"5" & '0' & x"0E"; -- STA @14      #seta flag de limite
tmp(229) := x"A" & '0' & x"00"; -- RET       
tmp(230) := x"4" & '0' & x"00"; -- LDI $0      
tmp(231) := x"5" & '1' & x"01"; -- STA @257      #LED mostra que nao alcancou limite
tmp(232) := x"5" & '0' & x"0E"; -- STA @14      #seta flag de limite
tmp(233) := x"A" & '0' & x"00"; -- RET       
tmp(234) := x"5" & '1' & x"FD"; -- STA @509      
tmp(235) := x"1" & '0' & x"10"; -- LDA @16      #le flag de limite 0
tmp(236) := x"8" & '0' & x"01"; -- CEQ $1      #compara com 1
tmp(237) := x"7" & '1' & x"2A"; -- JEQ @298      #se flag de limite 0 for 1, pula para :enddec
tmp(238) := x"1" & '0' & x"02"; -- LDA @2      #le count unidades
tmp(239) := x"8" & '0' & x"00"; -- CEQ $0      #compara com 0
tmp(240) := x"7" & '0' & x"F5"; -- JEQ @245      #se for 0, pula para :decd
tmp(241) := x"3" & '0' & x"01"; -- SUB @1      #subtrai 1
tmp(242) := x"5" & '1' & x"20"; -- STA @288      
tmp(243) := x"5" & '0' & x"02"; -- STA @2      #salva count unidades
tmp(244) := x"A" & '0' & x"00"; -- RET       
tmp(245) := x"4" & '0' & x"09"; -- LDI $9      
tmp(246) := x"5" & '0' & x"02"; -- STA @2      
tmp(247) := x"5" & '1' & x"20"; -- STA @288      
tmp(248) := x"1" & '0' & x"03"; -- LDA @3      #le count dezenas
tmp(249) := x"8" & '0' & x"00"; -- CEQ $0      #compara com 0
tmp(250) := x"7" & '0' & x"FF"; -- JEQ @255      #se for 0, pula para :decc
tmp(251) := x"3" & '0' & x"01"; -- SUB @1      #subtrai 1
tmp(252) := x"5" & '1' & x"21"; -- STA @289      
tmp(253) := x"5" & '0' & x"03"; -- STA @3      #salva count dezenas
tmp(254) := x"A" & '0' & x"00"; -- RET       
tmp(255) := x"4" & '0' & x"09"; -- LDI $9      
tmp(256) := x"5" & '0' & x"03"; -- STA @3      
tmp(257) := x"5" & '1' & x"21"; -- STA @289      
tmp(258) := x"1" & '0' & x"04"; -- LDA @4      #le count centenas
tmp(259) := x"8" & '0' & x"00"; -- CEQ $0      #compara com 0
tmp(260) := x"7" & '1' & x"09"; -- JEQ @265      #se for 0, pula para :decm
tmp(261) := x"3" & '0' & x"01"; -- SUB @1      #subtrai 1
tmp(262) := x"5" & '1' & x"22"; -- STA @290      
tmp(263) := x"5" & '0' & x"04"; -- STA @4      #salva count centenas
tmp(264) := x"A" & '0' & x"00"; -- RET       
tmp(265) := x"4" & '0' & x"09"; -- LDI $9      
tmp(266) := x"5" & '0' & x"04"; -- STA @4      
tmp(267) := x"5" & '1' & x"22"; -- STA @290      
tmp(268) := x"1" & '0' & x"05"; -- LDA @5      #le count milhares
tmp(269) := x"8" & '0' & x"00"; -- CEQ $0      #compara com 0
tmp(270) := x"7" & '1' & x"13"; -- JEQ @275      #se for 0, pula para :decdm
tmp(271) := x"3" & '0' & x"01"; -- SUB @1      #subtrai 1
tmp(272) := x"5" & '1' & x"23"; -- STA @291      
tmp(273) := x"5" & '0' & x"05"; -- STA @5      #salva count milhares
tmp(274) := x"A" & '0' & x"00"; -- RET       
tmp(275) := x"4" & '0' & x"09"; -- LDI $9      
tmp(276) := x"5" & '0' & x"05"; -- STA @5      
tmp(277) := x"5" & '1' & x"23"; -- STA @291      
tmp(278) := x"1" & '0' & x"06"; -- LDA @6      #le count dezenas de milhares
tmp(279) := x"8" & '0' & x"00"; -- CEQ $0      #compara com 0
tmp(280) := x"7" & '1' & x"1D"; -- JEQ @285      #se for 0, pula para :deccm
tmp(281) := x"3" & '0' & x"01"; -- SUB @1      #subtrai 1
tmp(282) := x"5" & '1' & x"24"; -- STA @292      
tmp(283) := x"5" & '0' & x"06"; -- STA @6      #salva count dezenas de milhares
tmp(284) := x"A" & '0' & x"00"; -- RET       
tmp(285) := x"4" & '0' & x"09"; -- LDI $9      
tmp(286) := x"5" & '0' & x"06"; -- STA @6      
tmp(287) := x"5" & '1' & x"24"; -- STA @292      
tmp(288) := x"1" & '0' & x"07"; -- LDA @7      #le count centenas de milhares
tmp(289) := x"8" & '0' & x"00"; -- CEQ $0      #compara com 0
tmp(290) := x"7" & '1' & x"27"; -- JEQ @295      #se for 0, pula para :retdec
tmp(291) := x"3" & '0' & x"01"; -- SUB @1      #subtrai 1
tmp(292) := x"5" & '1' & x"25"; -- STA @293      
tmp(293) := x"5" & '0' & x"07"; -- STA @7      #salva count centenas de milhares
tmp(294) := x"A" & '0' & x"00"; -- RET       
tmp(295) := x"4" & '0' & x"09"; -- LDI $9      
tmp(296) := x"5" & '0' & x"07"; -- STA @7      
tmp(297) := x"5" & '1' & x"25"; -- STA @293      
tmp(298) := x"A" & '0' & x"00"; -- RET       
tmp(299) := x"4" & '0' & x"00"; -- LDI $0      
tmp(300) := x"5" & '0' & x"10"; -- STA @16      #zera flag de limite 0
tmp(301) := x"8" & '0' & x"02"; -- CEQ @2      #compara count unidades
tmp(302) := x"C" & '1' & x"4F"; -- JNE @335      #se count unidades for diferente , pula para :retvz
tmp(303) := x"8" & '0' & x"03"; -- CEQ @3      #compara count dezenas
tmp(304) := x"C" & '1' & x"4F"; -- JNE @335      #se count dezenas for diferente, pula para :retvz
tmp(305) := x"8" & '0' & x"04"; -- CEQ @4      #compara count centenas
tmp(306) := x"C" & '1' & x"4F"; -- JNE @335      #se count centenas for diferente, pula para :retvz
tmp(307) := x"8" & '0' & x"05"; -- CEQ @5      #compara count milhares
tmp(308) := x"C" & '1' & x"4F"; -- JNE @335      #se count milhares for diferente, pula para :retvz
tmp(309) := x"8" & '0' & x"06"; -- CEQ @6      #compara count dezenas de milhares
tmp(310) := x"C" & '1' & x"4F"; -- JNE @335      #se count dezenas de milhares for diferente, pula para :retvz
tmp(311) := x"8" & '0' & x"07"; -- CEQ @7      #compara count centenas de milhares
tmp(312) := x"C" & '1' & x"4F"; -- JNE @335      #se count centenas de milhares for diferente, pula para :retvz
tmp(313) := x"4" & '0' & x"01"; -- LDI $1      
tmp(314) := x"5" & '0' & x"10"; -- STA @16      #seta flag de limite 0
tmp(315) := x"A" & '0' & x"00"; -- RET       
tmp(316) := x"4" & '0' & x"00"; -- LDI $0      
tmp(317) := x"5" & '0' & x"0F"; -- STA @15      #zera flag de limite 0
tmp(318) := x"5" & '1' & x"02"; -- STA @258      #zera led 9
tmp(319) := x"4" & '0' & x"09"; -- LDI $9      
tmp(320) := x"8" & '0' & x"02"; -- CEQ @2      #compara count unidades
tmp(321) := x"C" & '1' & x"4F"; -- JNE @335      #se count unidades for diferente , pula para :retvz
tmp(322) := x"8" & '0' & x"03"; -- CEQ @3      #compara count dezenas
tmp(323) := x"C" & '1' & x"4F"; -- JNE @335      #se count dezenas for diferente, pula para :retvz
tmp(324) := x"8" & '0' & x"04"; -- CEQ @4      #compara count centenas
tmp(325) := x"C" & '1' & x"4F"; -- JNE @335      #se count centenas for diferente, pula para :retvz
tmp(326) := x"8" & '0' & x"05"; -- CEQ @5      #compara count milhares
tmp(327) := x"C" & '1' & x"4F"; -- JNE @335      #se count milhares for diferente, pula para :retvz
tmp(328) := x"8" & '0' & x"06"; -- CEQ @6      #compara count dezenas de milhares
tmp(329) := x"C" & '1' & x"4F"; -- JNE @335      #se count dezenas de milhares for diferente, pula para :retvz
tmp(330) := x"8" & '0' & x"07"; -- CEQ @7      #compara count centenas de milhares
tmp(331) := x"C" & '1' & x"4F"; -- JNE @335      #se count centenas de milhares for diferente, pula para :retvz
tmp(332) := x"4" & '0' & x"01"; -- LDI $1      
tmp(333) := x"5" & '0' & x"0F"; -- STA @15      #seta flag de limite 0
tmp(334) := x"5" & '1' & x"02"; -- STA @258      #seta led 9
tmp(335) := x"A" & '0' & x"00"; -- RET       
tmp(336) := x"5" & '1' & x"FC"; -- STA @508      #limpa key 1
tmp(337) := x"1" & '0' & x"02"; -- LDA @2      # le count unidades
tmp(338) := x"5" & '1' & x"20"; -- STA @288      # mostra count unidades
tmp(339) := x"1" & '0' & x"03"; -- LDA @3      # le count dezenas
tmp(340) := x"5" & '1' & x"21"; -- STA @289      # mostra count dezenas
tmp(341) := x"1" & '0' & x"04"; -- LDA @4      # le count centenas
tmp(342) := x"5" & '1' & x"22"; -- STA @290      # mostra count centenas
tmp(343) := x"1" & '0' & x"05"; -- LDA @5      # le count milhares
tmp(344) := x"5" & '1' & x"23"; -- STA @291      # mostra count milhares
tmp(345) := x"1" & '0' & x"06"; -- LDA @6      # le count dezenas de milhares
tmp(346) := x"5" & '1' & x"24"; -- STA @292      # mostra count dezenas de milhares
tmp(347) := x"1" & '0' & x"07"; -- LDA @7      # le count centenas de milhares
tmp(348) := x"5" & '1' & x"25"; -- STA @293      # mostra count centenas de milhares
tmp(349) := x"4" & '0' & x"01"; -- LDI $1      
tmp(350) := x"5" & '1' & x"00"; -- STA @256      #LED mostra que configura_limite 1
tmp(351) := x"4" & '0' & x"0F"; -- LDI $15      
tmp(352) := x"B" & '1' & x"40"; -- AND @320      #mascara para Switch 70
tmp(353) := x"5" & '1' & x"20"; -- STA @288      #mostra Switch 70
tmp(354) := x"1" & '1' & x"63"; -- LDA @355      #le key 3
tmp(355) := x"B" & '0' & x"01"; -- AND @1      #mascara para key 3
tmp(356) := x"8" & '0' & x"01"; -- CEQ @1      #ve se key 3 foi pressionado
tmp(357) := x"C" & '1' & x"5F"; -- JNE @351      #se nao foi pressionado, volta para :loop_cnt_u
tmp(358) := x"5" & '1' & x"FC"; -- STA @508      #limpa key 3
tmp(359) := x"4" & '0' & x"0F"; -- LDI $15      
tmp(360) := x"B" & '1' & x"40"; -- AND @320      #mascara para Switch 70
tmp(361) := x"5" & '0' & x"02"; -- STA @2      #salva limite unidades
tmp(362) := x"4" & '0' & x"02"; -- LDI $2      
tmp(363) := x"5" & '1' & x"00"; -- STA @256      #LED mostra que configura_limite 2
tmp(364) := x"4" & '0' & x"0F"; -- LDI $15      
tmp(365) := x"B" & '1' & x"40"; -- AND @320      #mascara para Switch 70
tmp(366) := x"5" & '1' & x"21"; -- STA @289      #mostra Switch 70
tmp(367) := x"1" & '1' & x"63"; -- LDA @355      #le key 3
tmp(368) := x"B" & '0' & x"01"; -- AND @1      #mascara para key 3
tmp(369) := x"8" & '0' & x"01"; -- CEQ @1      #ve se key 3 foi pressionado
tmp(370) := x"C" & '1' & x"6C"; -- JNE @364      #se nao foi pressionado, volta para :loop_cnt_d
tmp(371) := x"5" & '1' & x"FC"; -- STA @508      #limpa key 3
tmp(372) := x"4" & '0' & x"0F"; -- LDI $15      
tmp(373) := x"B" & '1' & x"40"; -- AND @320      #mascara para Switch 70
tmp(374) := x"5" & '0' & x"03"; -- STA @3      #salva count dezenas
tmp(375) := x"4" & '0' & x"04"; -- LDI $4      
tmp(376) := x"5" & '1' & x"00"; -- STA @256      #LED mostra que configura_limite 3
tmp(377) := x"4" & '0' & x"0F"; -- LDI $15      
tmp(378) := x"B" & '1' & x"40"; -- AND @320      #mascara para Switch 70
tmp(379) := x"5" & '1' & x"22"; -- STA @290      #mostra Switch 70
tmp(380) := x"1" & '1' & x"63"; -- LDA @355      #le key 3
tmp(381) := x"B" & '0' & x"01"; -- AND @1      #mascara para key 3
tmp(382) := x"8" & '0' & x"01"; -- CEQ @1      #ve se key 3 foi pressionado
tmp(383) := x"C" & '1' & x"79"; -- JNE @377      #se nao foi pressionado, volta para :loop_cnt_c
tmp(384) := x"5" & '1' & x"FC"; -- STA @508      #limpa key 3
tmp(385) := x"4" & '0' & x"0F"; -- LDI $15      
tmp(386) := x"B" & '1' & x"40"; -- AND @320      #mascara para Switch 70
tmp(387) := x"5" & '0' & x"04"; -- STA @4      #salva count cenenas
tmp(388) := x"4" & '0' & x"08"; -- LDI $8      
tmp(389) := x"5" & '1' & x"00"; -- STA @256      #LED mostra que configura_limite 4
tmp(390) := x"4" & '0' & x"0F"; -- LDI $15      
tmp(391) := x"B" & '1' & x"40"; -- AND @320      #mascara para Switch 70
tmp(392) := x"5" & '1' & x"23"; -- STA @291      #mostra Switch 70
tmp(393) := x"1" & '1' & x"63"; -- LDA @355      #le key 3
tmp(394) := x"B" & '0' & x"01"; -- AND @1      #mascara para key 3
tmp(395) := x"8" & '0' & x"01"; -- CEQ @1      #ve se key 3 foi pressionado
tmp(396) := x"C" & '1' & x"86"; -- JNE @390      #se nao foi pressionado, volta para :loop_cnt_m
tmp(397) := x"5" & '1' & x"FC"; -- STA @508      #limpa key 3
tmp(398) := x"4" & '0' & x"0F"; -- LDI $15      
tmp(399) := x"B" & '1' & x"40"; -- AND @320      #mascara para Switch 70
tmp(400) := x"5" & '0' & x"05"; -- STA @5      #salva limite milhares
tmp(401) := x"4" & '0' & x"10"; -- LDI $16      
tmp(402) := x"5" & '1' & x"00"; -- STA @256      #LED mostra que configura_limite 5
tmp(403) := x"4" & '0' & x"0F"; -- LDI $15      
tmp(404) := x"B" & '1' & x"40"; -- AND @320      #mascara para Switch 70
tmp(405) := x"5" & '1' & x"24"; -- STA @292      #mostra Switch 70
tmp(406) := x"1" & '1' & x"63"; -- LDA @355      #le key 3
tmp(407) := x"B" & '0' & x"01"; -- AND @1      #mascara para key 3
tmp(408) := x"8" & '0' & x"01"; -- CEQ @1      #ve se key 3 foi pressionado
tmp(409) := x"C" & '1' & x"93"; -- JNE @403      #se nao foi pressionado, volta para :loop_cnt_dm
tmp(410) := x"5" & '1' & x"FC"; -- STA @508      #limpa key 1
tmp(411) := x"4" & '0' & x"0F"; -- LDI $15      
tmp(412) := x"B" & '1' & x"40"; -- AND @320      #mascara para Switch 70
tmp(413) := x"5" & '0' & x"06"; -- STA @6      #salva limite dezenas de milhares
tmp(414) := x"4" & '0' & x"20"; -- LDI $32      
tmp(415) := x"5" & '1' & x"00"; -- STA @256      #LED mostra que configura_limite 6
tmp(416) := x"4" & '0' & x"0F"; -- LDI $15      
tmp(417) := x"B" & '1' & x"40"; -- AND @320      #mascara para Switch 70
tmp(418) := x"5" & '1' & x"25"; -- STA @293      #mostra Switch 70
tmp(419) := x"1" & '1' & x"63"; -- LDA @355      #le key 1
tmp(420) := x"B" & '0' & x"01"; -- AND @1      #mascara para key 1
tmp(421) := x"8" & '0' & x"01"; -- CEQ @1      #ve se key 1 foi pressionado
tmp(422) := x"C" & '1' & x"A0"; -- JNE @416      #se nao foi pressionado, volta para :loop_cnt_cm
tmp(423) := x"5" & '1' & x"FC"; -- STA @508      #limpa key 1
tmp(424) := x"4" & '0' & x"0F"; -- LDI $15      
tmp(425) := x"B" & '1' & x"40"; -- AND @320      #mascara para Switch 70
tmp(426) := x"5" & '0' & x"07"; -- STA @7      #salva limite centenas de milhares
tmp(427) := x"4" & '0' & x"00"; -- LDI $0      
tmp(428) := x"5" & '1' & x"00"; -- STA @256      #LED mostra que configura_limite 0
tmp(429) := x"1" & '0' & x"02"; -- LDA @2      #comeca voltar valores hex
tmp(430) := x"5" & '1' & x"20"; -- STA @288      
tmp(431) := x"1" & '0' & x"03"; -- LDA @3      
tmp(432) := x"5" & '1' & x"21"; -- STA @289      
tmp(433) := x"1" & '0' & x"04"; -- LDA @4      
tmp(434) := x"5" & '1' & x"22"; -- STA @290      
tmp(435) := x"1" & '0' & x"05"; -- LDA @5      
tmp(436) := x"5" & '1' & x"23"; -- STA @291      
tmp(437) := x"1" & '0' & x"06"; -- LDA @6      
tmp(438) := x"5" & '1' & x"24"; -- STA @292      
tmp(439) := x"1" & '0' & x"07"; -- LDA @7      #termina voltar valores hex
tmp(440) := x"5" & '1' & x"25"; -- STA @293      
tmp(441) := x"A" & '0' & x"00"; -- RET       
